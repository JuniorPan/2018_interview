## 01 算法高频

题目一: 有一排正数，玩家A和玩家B都可以看到。每位玩家在拿走数字的时候，都只能从最左和最右的数中选择一个。玩家A先拿，玩家B再拿，两人交替拿走所有的数字，两人都力争自己拿到的数的总和比对方多。请返回最后获胜者的分数。

[486. Predict the Winner](https://leetcode.com/problems/predict-the-winner/)

```
class Solution
{
    // 作为先发者 在i...j范围上先发获得的收益
    int f(vector<int> &nums, int i, int j)
    {
        if (i == j) // 如果只有一个数并且又是先发者，则直接拿走该数
            return nums[i];

        else
            return max(s(nums, i + 1, j) + nums[i], s(nums, i, j - 1) + nums[j]);
    }
    // / 作为后发者 在i...j范围上后发获得的收益
    int s(vector<int> &nums, int i, int j)
    {
        if (i == j)
        {
            return 0;
        }
        else // 对方也是绝顶聪明,作为后发者,此时只能选先发者拿完之后 剩下最小的
            return min(f(nums, i + 1, j), f(nums, i, j - 1));
    }
public:
    bool PredictTheWinner(vector<int> &nums)
    {
        if (nums.empty())
            return false;
        int sum = 0;
        for (int i = 0; i < nums.size(); i++)
            sum += nums[i];

        int res = f(nums, 0, nums.size() - 1);
        return sum - res > res ? false : true;
    }
};
```

题目二：1、已知一个字符串都是由左括号(和右括号)组成，判断该字符串是否是有效的括号组合。
[20. Valid Parentheses](https://leetcode.com/problems/valid-parentheses/)

```
 bool isValid(string s)
{
    stack<char> st;
    for (char c : s)
    {
        if (c == '(' || c == '{' || c == '[')
        {
            st.push(c);
        }
        else
        {
            if (st.empty())
                return false;
            if (c == ')' && st.top() != '(')
                return false;
            if (c == '}' && st.top() != '{')
                return false;
            if (c == ']' && st.top() != '[')
                return false;
            st.pop();
        }
    }
    return st.empty();
}
```
1进阶、已知一个字符串都是由左括号(和右括号)组成，判断该字符串是否是有效的括号组合。

[32. Longest Valid Parentheses](https://leetcode.com/problems/longest-valid-parentheses/)

```
int longestValidParentheses(string s)
{
    int n = s.length();
    vector<int> dp(n, 0);  //dp[i]表示以s[i]结尾的最长有效字符串长度
    int res = 0;
    for(int i = 1; i < n; i++)
    {
        if (s[i] == '(') // 如果遇到左括号，说明以当前字符结尾不可能形成有效括号字符串，所以dp[i] = 0;
            dp[i] = 0; 

        if (s[i] == ')')  // 当前字符为右括号时，那么找到前一个字符位置形成的最长有效括号字符串的长度，在这个长度之前的字符串如果是左括号，那么可以形成有效括号字符串
            // 即 dp[i] = dp[i-1] + 2, 需要注意的是 需要加上 前一个字符位置形成的有效括号字符串；
        {
            int pre = i - dp[i-1] - 1;
            if (pre >= 0 && s[pre] == '(')
            {
                dp[i] = dp[i-1] + 2 + (pre > 0 ? dp[pre-1] : 0);
            }
        }
        res = max(res, dp[i]);
    }
    return res;
}
```


题目三： 高频1 视频4 （1:01开始）
1、给定一个数组，值全是正数，请返回累加和为给定值k的最长子数组长度。
2、给定一个数组，值可以为正、负和0，请返回累加和为给定值k的最长子数组长度。
3、给定一个数组，值可以为正、负和0，请返回累加和小于等于k的最长子数组长度。


## 01 算法高频
题目一:  实现栈中元素的逆序，只能用递归的方法

题目二: 小和问题（改写归并排序）
